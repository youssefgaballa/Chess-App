services:
  backend:
    container_name: nodejs-backend-container
    build: ./server
    depends_on:
      postgres:
        condition: service_healthy
    restart: on-failure:3
    ports:
      - "${BACKEND_PORT}:${BACKEND_PORT}"
    env_file:
      - ./server/example.env
      - ./.env
    develop:
      watch: 
        - path: ./server
          action: rebuild
          ignore: 
            - node_modules
            - .git/
          target: /app
        - path: ./server/package.json
          action: rebuild
        - path: ./server/tsconfig.json
          action: rebuild
        - path: ./docker-compose.yml
          action: rebuild
  postgres:
    container_name: postgres-db-container
    image: postgres:14.1-alpine
    restart: on-failure:3
    env_file:
      - ./server/example.env
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    volumes:
      # When the PostgresSQL container is started it will run any scripts
      # provided in the `docker-entrypoint-initdb.d` directory, this connects
      # our seed file to that directory so that it gets run
      - ./server/database-seed.sql:/docker-entrypoint-initdb.d/database-seed.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U root"]
      interval: 2s
      timeout: 5s
      retries: 5
      start_period: 15s
  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile
    develop:
      watch:
        - path: ./client
          action: rebuild
          ignore:
          - node_modules
          - .git/
          target: /app
        - path: ./client/package.json
          action: rebuild
    env_file:
      - ./.env
    ports:
      - ${FRONTEND_PORT}:${FRONTEND_PORT}
    depends_on:
      - backend

